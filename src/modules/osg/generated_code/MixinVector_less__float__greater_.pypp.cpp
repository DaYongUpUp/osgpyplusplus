// This file has been generated by Py++.

#include "boost/python.hpp"
#include "wrap_osg.h"
#include "mixinvector_less__float__greater_.pypp.hpp"

namespace bp = boost::python;

void register_MixinVector_less__float__greater__class(){

    { //::osg::MixinVector< float >
        typedef bp::class_< osg::MixinVector< float > > MixinVector_less__float__greater__exposer_t;
        MixinVector_less__float__greater__exposer_t MixinVector_less__float__greater__exposer = MixinVector_less__float__greater__exposer_t( "MixinVector_less__float__greater_", bp::init< >() );
        bp::scope MixinVector_less__float__greater__scope( MixinVector_less__float__greater__exposer );
        MixinVector_less__float__greater__exposer.def( bp::init< size_t, bp::optional< float const & > >(( bp::arg("initial_size"), bp::arg("fill_value")=typename std::vector<T, std::allocator<_Elem> >::value_type() )) );
        bp::implicitly_convertible< size_t, osg::MixinVector< float > >();
        MixinVector_less__float__greater__exposer.def( bp::init< std::vector< float > const & >(( bp::arg("other") )) );
        bp::implicitly_convertible< std::vector< float > const &, osg::MixinVector< float > >();
        MixinVector_less__float__greater__exposer.def( bp::init< osg::MixinVector< float > const & >(( bp::arg("other") )) );
        { //::osg::MixinVector< float >::asVector
        
            typedef osg::MixinVector< float > exported_class_t;
            typedef ::std::vector< float > & ( exported_class_t::*asVector_function_type)(  ) ;
            
            MixinVector_less__float__greater__exposer.def( 
                "asVector"
                , asVector_function_type( &::osg::MixinVector< float >::asVector )
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::MixinVector< float >::asVector
        
            typedef osg::MixinVector< float > exported_class_t;
            typedef ::std::vector< float > const & ( exported_class_t::*asVector_function_type)(  ) const;
            
            MixinVector_less__float__greater__exposer.def( 
                "asVector"
                , asVector_function_type( &::osg::MixinVector< float >::asVector )
                , bp::return_internal_reference< >() );
        
        }
        { //::osg::MixinVector< float >::assign
        
            typedef osg::MixinVector< float > exported_class_t;
            typedef void ( exported_class_t::*assign_function_type)( ::size_t,float const & ) ;
            
            MixinVector_less__float__greater__exposer.def( 
                "assign"
                , assign_function_type( &::osg::MixinVector< float >::assign )
                , ( bp::arg("count"), bp::arg("value") ) );
        
        }
        { //::osg::MixinVector< float >::at
        
            typedef osg::MixinVector< float > exported_class_t;
            typedef float const & ( exported_class_t::*at_function_type)( ::size_t ) const;
            
            MixinVector_less__float__greater__exposer.def( 
                "at"
                , at_function_type( &::osg::MixinVector< float >::at )
                , ( bp::arg("index") )
                , bp::return_value_policy< bp::copy_const_reference >() );
        
        }
        { //::osg::MixinVector< float >::at
        
            typedef osg::MixinVector< float > exported_class_t;
            typedef float & ( exported_class_t::*at_function_type)( ::size_t ) ;
            
            MixinVector_less__float__greater__exposer.def( 
                "at"
                , at_function_type( &::osg::MixinVector< float >::at )
                , ( bp::arg("index") )
                , bp::return_value_policy< bp::copy_non_const_reference >() );
        
        }
        { //::osg::MixinVector< float >::back
        
            typedef osg::MixinVector< float > exported_class_t;
            typedef float const & ( exported_class_t::*back_function_type)(  ) const;
            
            MixinVector_less__float__greater__exposer.def( 
                "back"
                , back_function_type( &::osg::MixinVector< float >::back )
                , bp::return_value_policy< bp::copy_const_reference >() );
        
        }
        { //::osg::MixinVector< float >::back
        
            typedef osg::MixinVector< float > exported_class_t;
            typedef float & ( exported_class_t::*back_function_type)(  ) ;
            
            MixinVector_less__float__greater__exposer.def( 
                "back"
                , back_function_type( &::osg::MixinVector< float >::back )
                , bp::return_value_policy< bp::copy_non_const_reference >() );
        
        }
        { //::osg::MixinVector< float >::begin
        
            typedef osg::MixinVector< float > exported_class_t;
            typedef ::std::_Vector_const_iterator< float, std::allocator< float > > ( exported_class_t::*begin_function_type)(  ) const;
            
            MixinVector_less__float__greater__exposer.def( 
                "begin"
                , begin_function_type( &::osg::MixinVector< float >::begin ) );
        
        }
        { //::osg::MixinVector< float >::begin
        
            typedef osg::MixinVector< float > exported_class_t;
            typedef ::std::_Vector_iterator< float, std::allocator< float > > ( exported_class_t::*begin_function_type)(  ) ;
            
            MixinVector_less__float__greater__exposer.def( 
                "begin"
                , begin_function_type( &::osg::MixinVector< float >::begin ) );
        
        }
        { //::osg::MixinVector< float >::capacity
        
            typedef osg::MixinVector< float > exported_class_t;
            typedef ::size_t ( exported_class_t::*capacity_function_type)(  ) const;
            
            MixinVector_less__float__greater__exposer.def( 
                "capacity"
                , capacity_function_type( &::osg::MixinVector< float >::capacity ) );
        
        }
        { //::osg::MixinVector< float >::clear
        
            typedef osg::MixinVector< float > exported_class_t;
            typedef void ( exported_class_t::*clear_function_type)(  ) ;
            
            MixinVector_less__float__greater__exposer.def( 
                "clear"
                , clear_function_type( &::osg::MixinVector< float >::clear ) );
        
        }
        { //::osg::MixinVector< float >::empty
        
            typedef osg::MixinVector< float > exported_class_t;
            typedef bool ( exported_class_t::*empty_function_type)(  ) const;
            
            MixinVector_less__float__greater__exposer.def( 
                "empty"
                , empty_function_type( &::osg::MixinVector< float >::empty ) );
        
        }
        { //::osg::MixinVector< float >::end
        
            typedef osg::MixinVector< float > exported_class_t;
            typedef ::std::_Vector_const_iterator< float, std::allocator< float > > ( exported_class_t::*end_function_type)(  ) const;
            
            MixinVector_less__float__greater__exposer.def( 
                "end"
                , end_function_type( &::osg::MixinVector< float >::end ) );
        
        }
        { //::osg::MixinVector< float >::end
        
            typedef osg::MixinVector< float > exported_class_t;
            typedef ::std::_Vector_iterator< float, std::allocator< float > > ( exported_class_t::*end_function_type)(  ) ;
            
            MixinVector_less__float__greater__exposer.def( 
                "end"
                , end_function_type( &::osg::MixinVector< float >::end ) );
        
        }
        { //::osg::MixinVector< float >::erase
        
            typedef osg::MixinVector< float > exported_class_t;
            typedef ::std::_Vector_iterator< float, std::allocator< float > > ( exported_class_t::*erase_function_type)( ::std::_Vector_iterator< float, std::allocator< float > > ) ;
            
            MixinVector_less__float__greater__exposer.def( 
                "erase"
                , erase_function_type( &::osg::MixinVector< float >::erase )
                , ( bp::arg("where") ) );
        
        }
        { //::osg::MixinVector< float >::erase
        
            typedef osg::MixinVector< float > exported_class_t;
            typedef ::std::_Vector_iterator< float, std::allocator< float > > ( exported_class_t::*erase_function_type)( ::std::_Vector_iterator< float, std::allocator< float > >,::std::_Vector_iterator< float, std::allocator< float > > ) ;
            
            MixinVector_less__float__greater__exposer.def( 
                "erase"
                , erase_function_type( &::osg::MixinVector< float >::erase )
                , ( bp::arg("first"), bp::arg("last") ) );
        
        }
        { //::osg::MixinVector< float >::front
        
            typedef osg::MixinVector< float > exported_class_t;
            typedef float const & ( exported_class_t::*front_function_type)(  ) const;
            
            MixinVector_less__float__greater__exposer.def( 
                "front"
                , front_function_type( &::osg::MixinVector< float >::front )
                , bp::return_value_policy< bp::copy_const_reference >() );
        
        }
        { //::osg::MixinVector< float >::front
        
            typedef osg::MixinVector< float > exported_class_t;
            typedef float & ( exported_class_t::*front_function_type)(  ) ;
            
            MixinVector_less__float__greater__exposer.def( 
                "front"
                , front_function_type( &::osg::MixinVector< float >::front )
                , bp::return_value_policy< bp::copy_non_const_reference >() );
        
        }
        { //::osg::MixinVector< float >::get_allocator
        
            typedef osg::MixinVector< float > exported_class_t;
            typedef ::std::allocator< float > ( exported_class_t::*get_allocator_function_type)(  ) const;
            
            MixinVector_less__float__greater__exposer.def( 
                "get_allocator"
                , get_allocator_function_type( &::osg::MixinVector< float >::get_allocator ) );
        
        }
        { //::osg::MixinVector< float >::insert
        
            typedef osg::MixinVector< float > exported_class_t;
            typedef ::std::_Vector_iterator< float, std::allocator< float > > ( exported_class_t::*insert_function_type)( ::std::_Vector_iterator< float, std::allocator< float > >,float const & ) ;
            
            MixinVector_less__float__greater__exposer.def( 
                "insert"
                , insert_function_type( &::osg::MixinVector< float >::insert )
                , ( bp::arg("where"), bp::arg("value") ) );
        
        }
        { //::osg::MixinVector< float >::insert
        
            typedef osg::MixinVector< float > exported_class_t;
            typedef void ( exported_class_t::*insert_function_type)( ::std::_Vector_iterator< float, std::allocator< float > >,::size_t,float const & ) ;
            
            MixinVector_less__float__greater__exposer.def( 
                "insert"
                , insert_function_type( &::osg::MixinVector< float >::insert )
                , ( bp::arg("where"), bp::arg("count"), bp::arg("value") ) );
        
        }
        { //::osg::MixinVector< float >::max_size
        
            typedef osg::MixinVector< float > exported_class_t;
            typedef ::size_t ( exported_class_t::*max_size_function_type)(  ) const;
            
            MixinVector_less__float__greater__exposer.def( 
                "max_size"
                , max_size_function_type( &::osg::MixinVector< float >::max_size ) );
        
        }
        { //::osg::MixinVector< float >::operator=
        
            typedef osg::MixinVector< float > exported_class_t;
            typedef ::osg::MixinVector< float > & ( exported_class_t::*assign_function_type)( ::std::vector< float > const & ) ;
            
            MixinVector_less__float__greater__exposer.def( 
                "assign"
                , assign_function_type( &::osg::MixinVector< float >::operator= )
                , ( bp::arg("other") )
                , bp::return_self< >() );
        
        }
        { //::osg::MixinVector< float >::operator=
        
            typedef osg::MixinVector< float > exported_class_t;
            typedef ::osg::MixinVector< float > & ( exported_class_t::*assign_function_type)( ::osg::MixinVector< float > const & ) ;
            
            MixinVector_less__float__greater__exposer.def( 
                "assign"
                , assign_function_type( &::osg::MixinVector< float >::operator= )
                , ( bp::arg("other") )
                , bp::return_self< >() );
        
        }
        { //::osg::MixinVector< float >::operator[]
        
            typedef osg::MixinVector< float > exported_class_t;
            typedef float const & ( exported_class_t::*__getitem___function_type)( ::size_t ) const;
            
            MixinVector_less__float__greater__exposer.def( 
                "__getitem__"
                , __getitem___function_type( &::osg::MixinVector< float >::operator[] )
                , ( bp::arg("index") )
                , bp::return_value_policy< bp::copy_const_reference >() );
        
        }
        { //::osg::MixinVector< float >::operator[]
        
            typedef osg::MixinVector< float > exported_class_t;
            typedef float & ( exported_class_t::*__getitem___function_type)( ::size_t ) ;
            
            MixinVector_less__float__greater__exposer.def( 
                "__getitem__"
                , __getitem___function_type( &::osg::MixinVector< float >::operator[] )
                , ( bp::arg("index") )
                , bp::return_value_policy< bp::copy_non_const_reference >() );
        
        }
        { //::osg::MixinVector< float >::pop_back
        
            typedef osg::MixinVector< float > exported_class_t;
            typedef void ( exported_class_t::*pop_back_function_type)(  ) ;
            
            MixinVector_less__float__greater__exposer.def( 
                "pop_back"
                , pop_back_function_type( &::osg::MixinVector< float >::pop_back ) );
        
        }
        { //::osg::MixinVector< float >::push_back
        
            typedef osg::MixinVector< float > exported_class_t;
            typedef void ( exported_class_t::*push_back_function_type)( float const & ) ;
            
            MixinVector_less__float__greater__exposer.def( 
                "push_back"
                , push_back_function_type( &::osg::MixinVector< float >::push_back )
                , ( bp::arg("value") ) );
        
        }
        { //::osg::MixinVector< float >::rbegin
        
            typedef osg::MixinVector< float > exported_class_t;
            typedef ::std::reverse_iterator< std::_Vector_const_iterator< float, std::allocator< float > > > ( exported_class_t::*rbegin_function_type)(  ) const;
            
            MixinVector_less__float__greater__exposer.def( 
                "rbegin"
                , rbegin_function_type( &::osg::MixinVector< float >::rbegin ) );
        
        }
        { //::osg::MixinVector< float >::rbegin
        
            typedef osg::MixinVector< float > exported_class_t;
            typedef ::std::reverse_iterator< std::_Vector_iterator< float, std::allocator< float > > > ( exported_class_t::*rbegin_function_type)(  ) ;
            
            MixinVector_less__float__greater__exposer.def( 
                "rbegin"
                , rbegin_function_type( &::osg::MixinVector< float >::rbegin ) );
        
        }
        { //::osg::MixinVector< float >::rend
        
            typedef osg::MixinVector< float > exported_class_t;
            typedef ::std::reverse_iterator< std::_Vector_const_iterator< float, std::allocator< float > > > ( exported_class_t::*rend_function_type)(  ) const;
            
            MixinVector_less__float__greater__exposer.def( 
                "rend"
                , rend_function_type( &::osg::MixinVector< float >::rend ) );
        
        }
        { //::osg::MixinVector< float >::rend
        
            typedef osg::MixinVector< float > exported_class_t;
            typedef ::std::reverse_iterator< std::_Vector_iterator< float, std::allocator< float > > > ( exported_class_t::*rend_function_type)(  ) ;
            
            MixinVector_less__float__greater__exposer.def( 
                "rend"
                , rend_function_type( &::osg::MixinVector< float >::rend ) );
        
        }
        { //::osg::MixinVector< float >::reserve
        
            typedef osg::MixinVector< float > exported_class_t;
            typedef void ( exported_class_t::*reserve_function_type)( ::size_t ) ;
            
            MixinVector_less__float__greater__exposer.def( 
                "reserve"
                , reserve_function_type( &::osg::MixinVector< float >::reserve )
                , ( bp::arg("new_capacity") ) );
        
        }
        { //::osg::MixinVector< float >::resize
        
            typedef osg::MixinVector< float > exported_class_t;
            typedef void ( exported_class_t::*resize_function_type)( ::size_t,float const & ) ;
            
            MixinVector_less__float__greater__exposer.def( 
                "resize"
                , resize_function_type( &::osg::MixinVector< float >::resize )
                , ( bp::arg("new_size"), bp::arg("fill_value")=typename std::vector<T, std::allocator<_Elem> >::value_type() ) );
        
        }
        { //::osg::MixinVector< float >::size
        
            typedef osg::MixinVector< float > exported_class_t;
            typedef ::size_t ( exported_class_t::*size_function_type)(  ) const;
            
            MixinVector_less__float__greater__exposer.def( 
                "size"
                , size_function_type( &::osg::MixinVector< float >::size ) );
        
        }
        { //::osg::MixinVector< float >::swap
        
            typedef osg::MixinVector< float > exported_class_t;
            typedef void ( exported_class_t::*swap_function_type)( ::std::vector< float > & ) ;
            
            MixinVector_less__float__greater__exposer.def( 
                "swap"
                , swap_function_type( &::osg::MixinVector< float >::swap )
                , ( bp::arg("other") ) );
        
        }
        { //::osg::MixinVector< float >::swap
        
            typedef osg::MixinVector< float > exported_class_t;
            typedef void ( exported_class_t::*swap_function_type)( ::osg::MixinVector< float > & ) ;
            
            MixinVector_less__float__greater__exposer.def( 
                "swap"
                , swap_function_type( &::osg::MixinVector< float >::swap )
                , ( bp::arg("other") ) );
        
        }
        MixinVector_less__float__greater__exposer.def( bp::self != bp::other< std::vector< float > >() );
        MixinVector_less__float__greater__exposer.def( bp::self != bp::self );
        MixinVector_less__float__greater__exposer.def( bp::self < bp::other< std::vector< float > >() );
        MixinVector_less__float__greater__exposer.def( bp::self < bp::self );
        MixinVector_less__float__greater__exposer.def( bp::self <= bp::other< std::vector< float > >() );
        MixinVector_less__float__greater__exposer.def( bp::self <= bp::self );
        MixinVector_less__float__greater__exposer.def( bp::self == bp::other< std::vector< float > >() );
        MixinVector_less__float__greater__exposer.def( bp::self == bp::self );
        MixinVector_less__float__greater__exposer.def( bp::self > bp::other< std::vector< float > >() );
        MixinVector_less__float__greater__exposer.def( bp::self > bp::self );
        MixinVector_less__float__greater__exposer.def( bp::self >= bp::other< std::vector< float > >() );
        MixinVector_less__float__greater__exposer.def( bp::self >= bp::self );
    }

}
