// This file has been generated by Py++.

#include "boost/python.hpp"
#include "wrap_osg.h"
#include "_osg_free_functions.pypp.hpp"

namespace bp = boost::python;

void register_free_functions(){

    { //::osg::DegreesToRadians
    
        typedef double ( *DegreesToRadians_function_type )( double );
        
        bp::def( 
            "DegreesToRadians"
            , DegreesToRadians_function_type( &::osg::DegreesToRadians )
            , ( bp::arg("angle") ) );
    
    }

    { //::osg::DegreesToRadians
    
        typedef float ( *DegreesToRadians_function_type )( float );
        
        bp::def( 
            "DegreesToRadians"
            , DegreesToRadians_function_type( &::osg::DegreesToRadians )
            , ( bp::arg("angle") ) );
    
    }

    { //::OpenThreads::GetNumberOfProcessors
    
        typedef int ( *GetNumberOfProcessors_function_type )(  );
        
        bp::def( 
            "GetNumberOfProcessors"
            , GetNumberOfProcessors_function_type( &::OpenThreads::GetNumberOfProcessors )
            , "  Get the number of processors.\n\n  Note, systems where no support exists for querrying the number of processors, 1 is returned." );
    
    }

    { //::osg::RadiansToDegrees
    
        typedef double ( *RadiansToDegrees_function_type )( double );
        
        bp::def( 
            "RadiansToDegrees"
            , RadiansToDegrees_function_type( &::osg::RadiansToDegrees )
            , ( bp::arg("angle") ) );
    
    }

    { //::osg::RadiansToDegrees
    
        typedef float ( *RadiansToDegrees_function_type )( float );
        
        bp::def( 
            "RadiansToDegrees"
            , RadiansToDegrees_function_type( &::osg::RadiansToDegrees )
            , ( bp::arg("angle") ) );
    
    }

    { //::OpenThreads::SetProcessorAffinityOfCurrentThread
    
        typedef int ( *SetProcessorAffinityOfCurrentThread_function_type )( unsigned int );
        
        bp::def( 
            "SetProcessorAffinityOfCurrentThread"
            , SetProcessorAffinityOfCurrentThread_function_type( &::OpenThreads::SetProcessorAffinityOfCurrentThread )
            , ( bp::arg("cpunum") )
            , "  Set the processor affinity of current thread.\n\n  Note, systems where no support exists no affinity will be set, and -1 will be returned." );
    
    }

    { //::osg::asciiToDouble
    
        typedef double ( *asciiToDouble_function_type )( char const * );
        
        bp::def( 
            "asciiToDouble"
            , asciiToDouble_function_type( &::osg::asciiToDouble )
            , ( bp::arg("str") )
            , " Convert a ascii number to a double, ignoring locale settings." );
    
    }

    { //::osg::asciiToFloat
    
        typedef float ( *asciiToFloat_function_type )( char const * );
        
        bp::def( 
            "asciiToFloat"
            , asciiToFloat_function_type( &::osg::asciiToFloat )
            , ( bp::arg("str") )
            , " Convert a ascii number to a float, ignoring locale settings." );
    
    }

    { //::osg::clampTo
    
        typedef double ( *clampTo_function_type )( double,double,double );
        
        bp::def( 
            "clampTo"
            , clampTo_function_type( &::osg::clampTo )
            , ( bp::arg("v"), bp::arg("minimum"), bp::arg("maximum") ) );
    
    }

    { //::osg::clampTo
    
        typedef float ( *clampTo_function_type )( float,float,float );
        
        bp::def( 
            "clampTo"
            , clampTo_function_type( &::osg::clampTo )
            , ( bp::arg("v"), bp::arg("minimum"), bp::arg("maximum") ) );
    
    }

    { //::osg::componentDivide
    
        typedef ::osg::Vec4us ( *componentDivide_function_type )( ::osg::Vec4us const &,::osg::Vec4us const & );
        
        bp::def( 
            "componentDivide"
            , componentDivide_function_type( &::osg::componentDivide )
            , ( bp::arg("lhs"), bp::arg("rhs") )
            , " divide rhs components by rhs vector components." );
    
    }

    { //::osg::componentDivide
    
        typedef ::osg::Vec3us ( *componentDivide_function_type )( ::osg::Vec3us const &,::osg::Vec3us const & );
        
        bp::def( 
            "componentDivide"
            , componentDivide_function_type( &::osg::componentDivide )
            , ( bp::arg("lhs"), bp::arg("rhs") )
            , " divide rhs components by rhs vector components." );
    
    }

    { //::osg::componentDivide
    
        typedef ::osg::Vec2us ( *componentDivide_function_type )( ::osg::Vec2us const &,::osg::Vec2us const & );
        
        bp::def( 
            "componentDivide"
            , componentDivide_function_type( &::osg::componentDivide )
            , ( bp::arg("lhs"), bp::arg("rhs") )
            , " divide rhs components by rhs vector components." );
    
    }

    { //::osg::componentDivide
    
        typedef ::osg::Vec3ub ( *componentDivide_function_type )( ::osg::Vec3ub const &,::osg::Vec3ub const & );
        
        bp::def( 
            "componentDivide"
            , componentDivide_function_type( &::osg::componentDivide )
            , ( bp::arg("lhs"), bp::arg("rhs") )
            , " divide rhs components by rhs vector components." );
    
    }

    { //::osg::componentDivide
    
        typedef ::osg::Vec2ub ( *componentDivide_function_type )( ::osg::Vec2ub const &,::osg::Vec2ub const & );
        
        bp::def( 
            "componentDivide"
            , componentDivide_function_type( &::osg::componentDivide )
            , ( bp::arg("lhs"), bp::arg("rhs") )
            , " divide rhs components by rhs vector components." );
    
    }

    { //::osg::componentDivide
    
        typedef ::osg::Vec4s ( *componentDivide_function_type )( ::osg::Vec4s const &,::osg::Vec4s const & );
        
        bp::def( 
            "componentDivide"
            , componentDivide_function_type( &::osg::componentDivide )
            , ( bp::arg("lhs"), bp::arg("rhs") )
            , " divide rhs components by rhs vector components." );
    
    }

    { //::osg::componentDivide
    
        typedef ::osg::Vec3s ( *componentDivide_function_type )( ::osg::Vec3s const &,::osg::Vec3s const & );
        
        bp::def( 
            "componentDivide"
            , componentDivide_function_type( &::osg::componentDivide )
            , ( bp::arg("lhs"), bp::arg("rhs") )
            , " divide rhs components by rhs vector components." );
    
    }

    { //::osg::componentDivide
    
        typedef ::osg::Vec2s ( *componentDivide_function_type )( ::osg::Vec2s const &,::osg::Vec2s const & );
        
        bp::def( 
            "componentDivide"
            , componentDivide_function_type( &::osg::componentDivide )
            , ( bp::arg("lhs"), bp::arg("rhs") )
            , " divide rhs components by rhs vector components." );
    
    }

    { //::osg::componentDivide
    
        typedef ::osg::Vec4d ( *componentDivide_function_type )( ::osg::Vec4d const &,::osg::Vec4d const & );
        
        bp::def( 
            "componentDivide"
            , componentDivide_function_type( &::osg::componentDivide )
            , ( bp::arg("lhs"), bp::arg("rhs") )
            , " divide rhs components by rhs vector components." );
    
    }

    { //::osg::componentDivide
    
        typedef ::osg::Vec4f ( *componentDivide_function_type )( ::osg::Vec4f const &,::osg::Vec4f const & );
        
        bp::def( 
            "componentDivide"
            , componentDivide_function_type( &::osg::componentDivide )
            , ( bp::arg("lhs"), bp::arg("rhs") )
            , " divide rhs components by rhs vector components." );
    
    }

    { //::osg::componentDivide
    
        typedef ::osg::Vec3d ( *componentDivide_function_type )( ::osg::Vec3d const &,::osg::Vec3d const & );
        
        bp::def( 
            "componentDivide"
            , componentDivide_function_type( &::osg::componentDivide )
            , ( bp::arg("lhs"), bp::arg("rhs") )
            , " divide rhs components by rhs vector components." );
    
    }

    { //::osg::componentDivide
    
        typedef ::osg::Vec3f ( *componentDivide_function_type )( ::osg::Vec3f const &,::osg::Vec3f const & );
        
        bp::def( 
            "componentDivide"
            , componentDivide_function_type( &::osg::componentDivide )
            , ( bp::arg("lhs"), bp::arg("rhs") )
            , " divide rhs components by rhs vector components." );
    
    }

    { //::osg::componentDivide
    
        typedef ::osg::Vec2d ( *componentDivide_function_type )( ::osg::Vec2d const &,::osg::Vec2d const & );
        
        bp::def( 
            "componentDivide"
            , componentDivide_function_type( &::osg::componentDivide )
            , ( bp::arg("lhs"), bp::arg("rhs") )
            , " divide rhs components by rhs vector components." );
    
    }

    { //::osg::componentDivide
    
        typedef ::osg::Vec2f ( *componentDivide_function_type )( ::osg::Vec2f const &,::osg::Vec2f const & );
        
        bp::def( 
            "componentDivide"
            , componentDivide_function_type( &::osg::componentDivide )
            , ( bp::arg("lhs"), bp::arg("rhs") )
            , " divide rhs components by rhs vector components." );
    
    }

    { //::osg::componentMultiply
    
        typedef ::osg::Vec4us ( *componentMultiply_function_type )( ::osg::Vec4us const &,::osg::Vec4us const & );
        
        bp::def( 
            "componentMultiply"
            , componentMultiply_function_type( &::osg::componentMultiply )
            , ( bp::arg("lhs"), bp::arg("rhs") )
            , " multiply by vector components." );
    
    }

    { //::osg::componentMultiply
    
        typedef ::osg::Vec3us ( *componentMultiply_function_type )( ::osg::Vec3us const &,::osg::Vec3us const & );
        
        bp::def( 
            "componentMultiply"
            , componentMultiply_function_type( &::osg::componentMultiply )
            , ( bp::arg("lhs"), bp::arg("rhs") )
            , " multiply by vector components." );
    
    }

    { //::osg::componentMultiply
    
        typedef ::osg::Vec2us ( *componentMultiply_function_type )( ::osg::Vec2us const &,::osg::Vec2us const & );
        
        bp::def( 
            "componentMultiply"
            , componentMultiply_function_type( &::osg::componentMultiply )
            , ( bp::arg("lhs"), bp::arg("rhs") )
            , " multiply by vector components." );
    
    }

    { //::osg::componentMultiply
    
        typedef ::osg::Vec3ub ( *componentMultiply_function_type )( ::osg::Vec3ub const &,::osg::Vec3ub const & );
        
        bp::def( 
            "componentMultiply"
            , componentMultiply_function_type( &::osg::componentMultiply )
            , ( bp::arg("lhs"), bp::arg("rhs") )
            , " multiply by vector components." );
    
    }

    { //::osg::componentMultiply
    
        typedef ::osg::Vec2ub ( *componentMultiply_function_type )( ::osg::Vec2ub const &,::osg::Vec2ub const & );
        
        bp::def( 
            "componentMultiply"
            , componentMultiply_function_type( &::osg::componentMultiply )
            , ( bp::arg("lhs"), bp::arg("rhs") )
            , " multiply by vector components." );
    
    }

    { //::osg::componentMultiply
    
        typedef ::osg::Vec4s ( *componentMultiply_function_type )( ::osg::Vec4s const &,::osg::Vec4s const & );
        
        bp::def( 
            "componentMultiply"
            , componentMultiply_function_type( &::osg::componentMultiply )
            , ( bp::arg("lhs"), bp::arg("rhs") )
            , " multiply by vector components." );
    
    }

    { //::osg::componentMultiply
    
        typedef ::osg::Vec3s ( *componentMultiply_function_type )( ::osg::Vec3s const &,::osg::Vec3s const & );
        
        bp::def( 
            "componentMultiply"
            , componentMultiply_function_type( &::osg::componentMultiply )
            , ( bp::arg("lhs"), bp::arg("rhs") )
            , " multiply by vector components." );
    
    }

    { //::osg::componentMultiply
    
        typedef ::osg::Vec2s ( *componentMultiply_function_type )( ::osg::Vec2s const &,::osg::Vec2s const & );
        
        bp::def( 
            "componentMultiply"
            , componentMultiply_function_type( &::osg::componentMultiply )
            , ( bp::arg("lhs"), bp::arg("rhs") )
            , " multiply by vector components." );
    
    }

    { //::osg::componentMultiply
    
        typedef ::osg::Vec4d ( *componentMultiply_function_type )( ::osg::Vec4d const &,::osg::Vec4d const & );
        
        bp::def( 
            "componentMultiply"
            , componentMultiply_function_type( &::osg::componentMultiply )
            , ( bp::arg("lhs"), bp::arg("rhs") )
            , " multiply by vector components." );
    
    }

    { //::osg::componentMultiply
    
        typedef ::osg::Vec4f ( *componentMultiply_function_type )( ::osg::Vec4f const &,::osg::Vec4f const & );
        
        bp::def( 
            "componentMultiply"
            , componentMultiply_function_type( &::osg::componentMultiply )
            , ( bp::arg("lhs"), bp::arg("rhs") )
            , " multiply by vector components." );
    
    }

    { //::osg::componentMultiply
    
        typedef ::osg::Vec3d ( *componentMultiply_function_type )( ::osg::Vec3d const &,::osg::Vec3d const & );
        
        bp::def( 
            "componentMultiply"
            , componentMultiply_function_type( &::osg::componentMultiply )
            , ( bp::arg("lhs"), bp::arg("rhs") )
            , " multiply by vector components." );
    
    }

    { //::osg::componentMultiply
    
        typedef ::osg::Vec3f ( *componentMultiply_function_type )( ::osg::Vec3f const &,::osg::Vec3f const & );
        
        bp::def( 
            "componentMultiply"
            , componentMultiply_function_type( &::osg::componentMultiply )
            , ( bp::arg("lhs"), bp::arg("rhs") )
            , " multiply by vector components." );
    
    }

    { //::osg::componentMultiply
    
        typedef ::osg::Vec2d ( *componentMultiply_function_type )( ::osg::Vec2d const &,::osg::Vec2d const & );
        
        bp::def( 
            "componentMultiply"
            , componentMultiply_function_type( &::osg::componentMultiply )
            , ( bp::arg("lhs"), bp::arg("rhs") )
            , " multiply by vector components." );
    
    }

    { //::osg::componentMultiply
    
        typedef ::osg::Vec2f ( *componentMultiply_function_type )( ::osg::Vec2f const &,::osg::Vec2f const & );
        
        bp::def( 
            "componentMultiply"
            , componentMultiply_function_type( &::osg::componentMultiply )
            , ( bp::arg("lhs"), bp::arg("rhs") )
            , " multiply by vector components." );
    
    }

    { //::osg::computeEyeToLocal
    
        typedef ::osg::Matrix ( *computeEyeToLocal_function_type )( ::osg::Matrix const &,::osg::NodePath const &,bool );
        
        bp::def( 
            "computeEyeToLocal"
            , computeEyeToLocal_function_type( &::osg::computeEyeToLocal )
            , ( bp::arg("modelview"), bp::arg("nodePath"), bp::arg("ignoreCameras")=(bool)(true) )
            , " Compute the matrix which transforms objects in eye coords to local coords,\n by accumulating the Transform world to local matrices along the specified node path\n and multiplying by the inverse of the supplied initial camera modelview." );
    
    }

    { //::osg::computeLocalToEye
    
        typedef ::osg::Matrix ( *computeLocalToEye_function_type )( ::osg::Matrix const &,::osg::NodePath const &,bool );
        
        bp::def( 
            "computeLocalToEye"
            , computeLocalToEye_function_type( &::osg::computeLocalToEye )
            , ( bp::arg("modelview"), bp::arg("nodePath"), bp::arg("ignoreCameras")=(bool)(true) )
            , " Compute the matrix which transforms objects in local coords to eye coords,\n by accumulating the Transform local to world matrices along the specified node path\n and multiplying by the supplied initial camera modelview." );
    
    }

    { //::osg::computeLocalToWorld
    
        typedef ::osg::Matrix ( *computeLocalToWorld_function_type )( ::osg::NodePath const &,bool );
        
        bp::def( 
            "computeLocalToWorld"
            , computeLocalToWorld_function_type( &::osg::computeLocalToWorld )
            , ( bp::arg("nodePath"), bp::arg("ignoreCameras")=(bool)(true) )
            , " Compute the matrix which transforms objects in local coords to world coords,\n by accumulating the Transform local to world matrices along the specified node path." );
    
    }

    { //::osg::computeWorldToLocal
    
        typedef ::osg::Matrix ( *computeWorldToLocal_function_type )( ::osg::NodePath const &,bool );
        
        bp::def( 
            "computeWorldToLocal"
            , computeWorldToLocal_function_type( &::osg::computeWorldToLocal )
            , ( bp::arg("nodePath"), bp::arg("ignoreCameras")=(bool)(true) )
            , " Compute the matrix which transforms objects in world coords to local coords,\n by accumulating the Transform world to local matrices along the specified node path." );
    
    }

    { //::osg::createGeodeForImage
    
        typedef ::osg::Geode * ( *createGeodeForImage_function_type )( ::osg::Image *,float,float );
        
        bp::def( 
            "createGeodeForImage"
            , createGeodeForImage_function_type( &::osg::createGeodeForImage )
            , ( bp::arg("image"), bp::arg("s"), bp::arg("t") )
            , bp::return_value_policy< bp::reference_existing_object >()
            , " Convenience function to be used by image loaders to generate a valid geode\n to return for readNode().\n Use the specified s and t values to scale the dimensions of the image." );
    
    }

    { //::osg::createGeodeForImage
    
        typedef ::osg::Geode * ( *createGeodeForImage_function_type )( ::osg::Image * );
        
        bp::def( 
            "createGeodeForImage"
            , createGeodeForImage_function_type( &::osg::createGeodeForImage )
            , ( bp::arg("image") )
            , bp::return_value_policy< bp::reference_existing_object >()
            , " Convenience function to be used by image loaders to generate a valid geode\n to return for readNode().\n Use the images s and t values to scale the dimensions of the image." );
    
    }

    { //::osg::createTexturedQuadGeometry
    
        typedef ::osg::Geometry * ( *createTexturedQuadGeometry_function_type )( ::osg::Vec3 const &,::osg::Vec3 const &,::osg::Vec3 const &,float,float );
        
        bp::def( 
            "createTexturedQuadGeometry"
            , createTexturedQuadGeometry_function_type( &::osg::createTexturedQuadGeometry )
            , ( bp::arg("corner"), bp::arg("widthVec"), bp::arg("heightVec"), bp::arg("s")=1.0e+0f, bp::arg("t")=1.0e+0f )
            , bp::return_value_policy< bp::reference_existing_object >()
            , " Convenience function to be used for creating quad geometry with texture coords.\n Tex coords go from bottom left (0,0) to top right (s,t)." );
    
    }

    { //::osg::createTexturedQuadGeometry
    
        typedef ::osg::Geometry * ( *createTexturedQuadGeometry_function_type )( ::osg::Vec3 const &,::osg::Vec3 const &,::osg::Vec3 const &,float,float,float,float );
        
        bp::def( 
            "createTexturedQuadGeometry"
            , createTexturedQuadGeometry_function_type( &::osg::createTexturedQuadGeometry )
            , ( bp::arg("corner"), bp::arg("widthVec"), bp::arg("heightVec"), bp::arg("l"), bp::arg("b"), bp::arg("r"), bp::arg("t") )
            , bp::return_value_policy< bp::reference_existing_object >()
            , " Convenience function to be used for creating quad geometry with texture coords.\n Tex coords go from left bottom (l,b) to right top (r,t)." );
    
    }

    { //::osg::equivalent
    
        typedef bool ( *equivalent_function_type )( double,double,double );
        
        bp::def( 
            "equivalent"
            , equivalent_function_type( &::osg::equivalent )
            , ( bp::arg("lhs"), bp::arg("rhs"), bp::arg("epsilon")=9.99999999999999954748111825886258685613938723691e-7 )
            , " return true if double lhs and rhs are equivalent,\n meaning that the difference between them is less than an epsilon value\n which defaults to 1e-6." );
    
    }

    { //::osg::equivalent
    
        typedef bool ( *equivalent_function_type )( float,float,float );
        
        bp::def( 
            "equivalent"
            , equivalent_function_type( &::osg::equivalent )
            , ( bp::arg("lhs"), bp::arg("rhs"), bp::arg("epsilon")=9.99999999999999954748111825886258685613938723691e-7 )
            , " return true if float lhs and rhs are equivalent,\n meaning that the difference between them is less than an epsilon value\n which defaults to 1e-6." );
    
    }

    { //::osg::findAsciiToDouble
    
        typedef double ( *findAsciiToDouble_function_type )( char const * );
        
        bp::def( 
            "findAsciiToDouble"
            , findAsciiToDouble_function_type( &::osg::findAsciiToDouble )
            , ( bp::arg("str") )
            , " Detect first ascii POSITIVE number in string and convert to double." );
    
    }

    { //::osg::findAsciiToFloat
    
        typedef float ( *findAsciiToFloat_function_type )( char const * );
        
        bp::def( 
            "findAsciiToFloat"
            , findAsciiToFloat_function_type( &::osg::findAsciiToFloat )
            , ( bp::arg("str") )
            , " Detect first ascii POSITIVE number in string and convert to double." );
    
    }

    { //::osg::getBinding
    
        typedef ::osg::Array::Binding ( *getBinding_function_type )( ::osg::Array const * );
        
        bp::def( 
            "getBinding"
            , getBinding_function_type( &::osg::getBinding )
            , ( bp::arg("array") )
            , " convinience function for getting the binding of array via a ptr that may be null." );
    
    }

    { //::osg::getNormalize
    
        typedef bool ( *getNormalize_function_type )( ::osg::Array const * );
        
        bp::def( 
            "getNormalize"
            , getNormalize_function_type( &::osg::getNormalize )
            , ( bp::arg("array") )
            , " convinience function for getting the binding of array via a ptr that may be null." );
    
    }

    { //::osg::getNotifyHandler
    
        typedef ::osg::NotifyHandler * ( *getNotifyHandler_function_type )(  );
        
        bp::def( 
            "getNotifyHandler"
            , getNotifyHandler_function_type( &::osg::getNotifyHandler )
            , bp::return_value_policy< bp::reference_existing_object >()
            , " Get currrent notification handler." );
    
    }

    { //::osg::getNotifyLevel
    
        typedef ::osg::NotifySeverity ( *getNotifyLevel_function_type )(  );
        
        bp::def( 
            "getNotifyLevel"
            , getNotifyLevel_function_type( &::osg::getNotifyLevel )
            , " get the notify level." );
    
    }

    { //::osg::inDegrees
    
        typedef double ( *inDegrees_function_type )( double );
        
        bp::def( 
            "inDegrees"
            , inDegrees_function_type( &::osg::inDegrees )
            , ( bp::arg("angle") ) );
    
    }

    { //::osg::inDegrees
    
        typedef float ( *inDegrees_function_type )( float );
        
        bp::def( 
            "inDegrees"
            , inDegrees_function_type( &::osg::inDegrees )
            , ( bp::arg("angle") ) );
    
    }

    { //::osg::initNotifyLevel
    
        typedef bool ( *initNotifyLevel_function_type )(  );
        
        bp::def( 
            "initNotifyLevel"
            , initNotifyLevel_function_type( &::osg::initNotifyLevel )
            , " initialize notify level." );
    
    }

    { //::osg::intrusive_ptr_add_ref
    
        typedef void ( *intrusive_ptr_add_ref_function_type )( ::osg::Referenced * );
        
        bp::def( 
            "intrusive_ptr_add_ref"
            , intrusive_ptr_add_ref_function_type( &::osg::intrusive_ptr_add_ref )
            , ( bp::arg("p") ) );
    
    }

    { //::osg::intrusive_ptr_release
    
        typedef void ( *intrusive_ptr_release_function_type )( ::osg::Referenced * );
        
        bp::def( 
            "intrusive_ptr_release"
            , intrusive_ptr_release_function_type( &::osg::intrusive_ptr_release )
            , ( bp::arg("p") ) );
    
    }

    { //::osg::isNaN
    
        typedef bool ( *isNaN_function_type )( double );
        
        bp::def( 
            "isNaN"
            , isNaN_function_type( &::osg::isNaN )
            , ( bp::arg("v") ) );
    
    }

    { //::osg::isNotifyEnabled
    
        typedef bool ( *isNotifyEnabled_function_type )( ::osg::NotifySeverity );
        
        bp::def( 
            "isNotifyEnabled"
            , isNotifyEnabled_function_type( &::osg::isNotifyEnabled )
            , ( bp::arg("severity") )
            , " is notification enabled, given the current setNotifyLevel() setting?" );
    
    }

    { //::osg::isTextureMode
    
        typedef bool ( *isTextureMode_function_type )( ::GLenum );
        
        bp::def( 
            "isTextureMode"
            , isTextureMode_function_type( &::osg::isTextureMode )
            , ( bp::arg("mode") ) );
    
    }

    { //::osg::maximum
    
        typedef int ( *maximum_function_type )( int,int );
        
        bp::def( 
            "maximum"
            , maximum_function_type( &::osg::maximum )
            , ( bp::arg("lhs"), bp::arg("rhs") )
            , " return the maximum of two values, equivalent to std::max.\n std::max not used because of STL implementation under IRIX not containing\n std::max." );
    
    }

    { //::osg::notify
    
        typedef ::std::ostream & ( *notify_function_type )(  );
        
        bp::def( 
            "notify"
            , notify_function_type( &::osg::notify )
            , bp::return_value_policy< bp::reference_existing_object >() );
    
    }

    { //::osg::notify
    
        typedef ::std::ostream & ( *notify_function_type )( ::osg::NotifySeverity const );
        
        bp::def( 
            "notify"
            , notify_function_type( &::osg::notify )
            , ( bp::arg("severity") )
            , bp::return_value_policy< bp::reference_existing_object >()
            , " notify messaging function for providing fatal through to verbose\n debugging messages.  Level of messages sent to the console can\n be controlled by setting the NotifyLevel either within your\n application or via the an environmental variable i.e.\n - setenv OSGNOTIFYLEVEL DEBUG (for tsh)\n - export OSGNOTIFYLEVEL=DEBUG (for bourne shell)\n - set OSGNOTIFYLEVEL=DEBUG (for Windows)\n\n All tell the osg to redirect all debugging and more important messages\n to the notification stream (useful for debugging) setting ALWAYS will force\n all messages to be absorbed, which might be appropriate for final\n applications.  Default NotifyLevel is NOTICE.  Check the enum\n #NotifySeverity for full range of possibilities.  To use the notify\n with your code simply use the notify function as a normal file\n stream (like std::cout) i.e\n [Code]\n osg::notify(osg::DEBUG) << Hello Bugs! << std::endl;\n E:ndcode\n aee setNotifyLevel, setNotifyHandler" );
    
    }

    { //::osgGetLibraryName
    
        typedef char const * ( *osgGetLibraryName_function_type )(  );
        
        bp::def( 
            "osgGetLibraryName"
            , osgGetLibraryName_function_type( &::osgGetLibraryName )
            , " The osgGetLibraryName() method returns the library name in human-friendly form." );
    
    }

    { //::osgGetSOVersion
    
        typedef char const * ( *osgGetSOVersion_function_type )(  );
        
        bp::def( 
            "osgGetSOVersion"
            , osgGetSOVersion_function_type( &::osgGetSOVersion )
            , " The osgGetSOVersion() method returns the OpenSceneGraph shared object version number." );
    
    }

    { //::osgGetVersion
    
        typedef char const * ( *osgGetVersion_function_type )(  );
        
        bp::def( 
            "osgGetVersion"
            , osgGetVersion_function_type( &::osgGetVersion )
            , " osgGetVersion() returns the library version number.\n Numbering convention : OpenSceneGraph-1.0 will return 1.0 from osgGetVersion.\n\n This C function can be also used to check for the existence of the OpenSceneGraph\n library using autoconf and its m4 macro AC_CHECK_LIB.\n\n Here is the code to add to your configure.in:\n Verbatim:\n #\n # Check for the OpenSceneGraph (OSG) library\n #\n AC_CHECK_LIB(osg, osgGetVersion, ,\n    [AC_MSG_ERROR(OpenSceneGraph library not found. See http://www.openscenegraph.org)],)\n E:ndverbatim" );
    
    }

    { //::osg::round
    
        typedef double ( *round_function_type )( double );
        
        bp::def( 
            "round"
            , round_function_type( &::osg::round )
            , ( bp::arg("v") ) );
    
    }

    { //::osg::round
    
        typedef float ( *round_function_type )( float );
        
        bp::def( 
            "round"
            , round_function_type( &::osg::round )
            , ( bp::arg("v") ) );
    
    }

    { //::osg::setNotifyHandler
    
        typedef void ( *setNotifyHandler_function_type )( ::osg::NotifyHandler * );
        
        bp::def( 
            "setNotifyHandler"
            , setNotifyHandler_function_type( &::osg::setNotifyHandler )
            , ( bp::arg("handler") )
            , " Set notification handler, by default StandardNotifyHandler is used.\n aee NotifyHandler" );
    
    }

    { //::osg::setNotifyLevel
    
        typedef void ( *setNotifyLevel_function_type )( ::osg::NotifySeverity );
        
        bp::def( 
            "setNotifyLevel"
            , setNotifyLevel_function_type( &::osg::setNotifyLevel )
            , ( bp::arg("severity") )
            , " set the notify level, overriding the default or the value set by\n the environmental variable OSGNOTIFYLEVEL or OSG_NOTIFY_LEVEL." );
    
    }

}
